import numpy as np
from ukf_fusion import UKF

def run_sim(seed=0, T=120, attack_start=60, bias=np.array([1.0, 1.0, 0.5])):
    np.random.seed(seed)
    ukf = UKF()

    # ground-truth state (x, y, yaw)
    x_true = np.array([0.0, 0.0, 0.0], dtype=float)

    detected_at = None
    flagged_count = 0

    for t in range(T):
        # Simple motion model for truth (not using ukf.predict here because your file may be minimal)
        x_true = x_true + np.array([0.05, 0.02, 0.01])


        # Control input consistent with the truth motion (vx, vy, yaw_rate)
        # Adjust if your UKF uses a different convention for u.
        u = np.array([0.05 / 1.0, 0.02 / 1.0, 0.01 / 1.0], dtype=float)
        dt = 1.0
        ukf.predict(u, dt)


        # VO measurement: truth + noise
        z_vo = x_true + np.random.multivariate_normal(mean=np.zeros(3), cov=ukf.R_vo_nominal)

        # Inject attack bias after attack_start
        if t >= attack_start:
            z_vo = z_vo + bias

        # IMU yaw measurement: truth yaw + noise
        yaw_meas = float(x_true[2] + np.random.normal(0.0, np.sqrt(ukf.R_imu_nominal[0, 0])))

        # Updates

        ukf.update_vo(z_vo)

        # Debug: print around attack window and every 10 steps
        if (t % 10 == 0) or (attack_start - 5 <= t <= attack_start + 10):
            info_vo = ukf.mon_vo.update(np.zeros(3), np.eye(3), meta={"dbg": True})  # placeholder
            # We can't access last info directly, so we infer via current R.
            print(f"t={t:03d} attack={'YES' if t>=attack_start else 'no '} "
                  f"R_vo_inflated={np.allclose(ukf.R_vo, ukf.R_vo_nominal*10.0)} "
                  f"security_alert={ukf.security_alert}")


        ukf.update_imu(yaw_meas)

        # Detection bookkeeping
        # We infer detection from the monitor streak / triggered indirectly via security_alert.
        # security_alert is sticky once triggered.
        if ukf.security_alert and detected_at is None:
            detected_at = t

        # For a bit more detail, count how often VO is getting down-weighted (R inflated)
        if np.allclose(ukf.R_vo, ukf.R_vo_nominal * 10.0):
            flagged_count += 1

    return detected_at, flagged_count

if __name__ == "__main__":
    detected_at, flagged_count = run_sim()
    print("Detected at step:", detected_at)
    print("VO down-weighted steps:", flagged_count)
