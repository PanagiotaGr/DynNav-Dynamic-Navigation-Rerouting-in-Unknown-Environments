import numpy as np
from security_monitor import InnovationMonitor, MonitorConfig

class UKF:
    def __init__(self):
        # State: x, y, yaw
        self.x = np.zeros(3)
        self.P = np.eye(3) * 0.1

        # Process noise
        self.Q = np.diag([0.05, 0.05, 0.01])

        # Measurement noise
        self.R_vo = np.diag([0.05, 0.05, 0.02])
        self.R_imu = np.array([[0.01]])

        # UKF parameters
        self.alpha = 1e-3
        self.beta = 2
        self.kappa = 0

        # --- Innovation-based IDS monitors (VO + IMU) ---
        cfg = MonitorConfig(alpha=0.01, consecutive=3, window=200, warmup=20)
        self.mon_vo = InnovationMonitor(cfg)
        self.mon_imu = InnovationMonitor(cfg)
        self.security_alert = False

        # Store nominal measurement noise (for adaptive trust weighting)
        self.R_vo_nominal = self.R_vo.copy()
        self.R_imu_nominal = self.R_imu.copy()



    def sigma_points(self, x, P):
        n = len(x)
        lambda_ = self.alpha**2 * (n + self.kappa) - n
        U = np.linalg.cholesky((n + lambda_) * P)

        sigma = [x]
        for i in range(n):
            sigma.append(x + U[i])
            sigma.append(x - U[i])

        return np.array(sigma), lambda_

    def motion_model(self, x, u, dt):
        vx, vy, yaw_rate = u
        x_new = np.zeros(3)
        x_new[0] = x[0] + vx * dt
        x_new[1] = x[1] + vy * dt
        x_new[2] = x[2] + yaw_rate * dt
        return x_new

    def predict(self, u, dt):
        sigma, lambda_ = self.sigma_points(self.x, self.P)
        n = len(self.x)
        w0 = lambda_ / (n + lambda_)
        wi = 1 / (2 * (n + lambda_))

        sigma_pred = np.array([self.motion_model(sp, u, dt) for sp in sigma])

        # Weighted mean
        x_pred = w0 * sigma_pred[0]
        for s in sigma_pred[1:]:
            x_pred += wi * s

        # Weighted covariance
        P_pred = self.Q.copy()
        for i, sp in enumerate(sigma_pred):
            diff = (sp - x_pred).reshape(-1, 1)
            w = w0 if i == 0 else wi
            P_pred += w * (diff @ diff.T)

        self.x = x_pred
        self.P = P_pred

    def update_vo(self, z):
        # Measurement: direct observation of x,y,yaw
        H = np.eye(3)
        S = H @ self.P @ H.T + self.R_vo
        K = self.P @ H.T @ np.linalg.inv(S)
        y = z - H @ self.x
        # IDS: innovation gating
        info = self.mon_vo.update(y, S, meta={"sensor": "vo"})
        if info["triggered"]:
            self.security_alert = True
            # Mitigation: down-weight VO by inflating its measurement noise
            self.R_vo = self.R_vo_nominal * 10.0
        else:
            # gradually recover to nominal if not in alert
            self.R_vo = self.R_vo_nominal

        self.x = self.x + K @ y
        self.P = (np.eye(3) - K @ H) @ self.P

    def update_imu(self, yaw_meas):
        H = np.array([[0, 0, 1]])
        S = H @ self.P @ H.T + self.R_imu
        K = self.P @ H.T @ np.linalg.inv(S)

        y = yaw_meas - H @ self.x

        # IDS: innovation gating
        info = self.mon_imu.update(np.array([float(y)]), S, meta={"sensor": "imu"})
        if info["triggered"]:
            self.security_alert = True
            # Mitigation: down-weight IMU by inflating its measurement noise
            self.R_imu = self.R_imu_nominal * 10.0
        else:
            self.R_imu = self.R_imu_nominal
        self.x = self.x + K @ y
        self.P = (np.eye(3) - K @ H) @ self.P


